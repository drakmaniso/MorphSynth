class "MorphSynth"

require "MorphSynthWindow"
require "WaveFunctions"

require "utils"

----------------------------------------------------------------------------------------------------


function MorphSynth:__init ()

    self.instrument = renoise.song().selected_instrument

    if
        self.instrument.name == ""
        and #self.instrument.samples == 0
    then
        self.instrument.name = "[MorphSynth]"
    end

    local e = self:load_parameters ()

    if not e then

        self.window = MorphSynthWindow (self)

        self.window:show_dialog ()

    end

end



----------------------------------------------------------------------------------------------------


function MorphSynth:generate_samples ()

    -- Clear the samples previously generated by MorphSynth
    local i = 1
    while i <= #self.instrument.samples do
        if string.sub (self.instrument:sample(i).name, 1, 15) == "MorphSynth Note" then
            self.instrument:delete_sample_at (i)
        else
            i = i + 1
        end
    end

    self:save_parameters ()


    local first_note = self.first_note
    local last_note = self.last_note
    if first_note > last_note then
        first_note, last_note = last_note, first_note
    end

    local note = first_note
    local range_start, range_end

    repeat

        --~ in_progress_yield ()
        if note == first_note then
            range_start = 0
        else
            range_start = note
        end
        if note + self.keyzones_step > last_note then
            range_end = 119
        else
            range_end = note + self.keyzones_step - 1
        end

        for i = 1, 8 do
            if #self.voices[i].carrier.waveforms > 0 then
                self:generate_one_sample (note, range_start, range_end, i)
            end
        end

        note = note + self.keyzones_step

    until note > last_note

end


----------------------------------------------------------------------------------------------------

function MorphSynth:update_positions (section, period)

    local position = 1
    for j = 1, #section.waveforms do
        section.waveforms[j].position = position
        if section.durations[j].unit == "ms" then
            position = position + section.durations[j].value / 1000 * self.sample_rate
        elseif section.durations[j].unit == "s" then
            position = position + section.durations[j].value * self.sample_rate
        else
            position = position + section.durations[j].value * period
        end
    end

end


function MorphSynth:generate_one_sample (note, range_start, range_end, voice_index)

    local voice = self.voices[voice_index]

    local sample_rate = self.sample_rate

    local f = frequency_of_renoise_note (note + voice.transpose) ---TODO: boundary check
    local period = sample_rate / f

    self:update_positions (voice.carrier, period)
    self:update_positions (voice.ring_modulator, period)
    self:update_positions (voice.frequency_modulator_1, period)
    self:update_positions (voice.frequency_modulator_2, period)

    local nb_frames = math.floor (voice.carrier.waveforms[#voice.carrier.waveforms].position / period + 0.5) * period
    if nb_frames == 0 then
        nb_frames = period
    end

    local samples = {}
    for i = 1, nb_frames do
        samples[i] = 0
    end

    local ring_modulator_length = voice.ring_modulator.waveforms[#voice.ring_modulator.waveforms].position

    WaveFunctions.initialize_random_seed (voice.seed * note * 127)

    local phase = 0
    local rm_phase = 0
    local fm1_phase = 0
    local fm2_phase = 0
    for i = 1, #samples do

        -- Find the current segment for the carrier, ring modulator and FM modulators

        local index = 0
        repeat
            index = index + 1
        until index == #voice.carrier.waveforms
            or ((i >= voice.carrier.waveforms[index].position) and (i <= voice.carrier.waveforms[index + 1].position))

        local rm_index = 0
        repeat
            rm_index = rm_index + 1
        until rm_index == #voice.ring_modulator.waveforms
            or ((i >= voice.ring_modulator.waveforms[rm_index].position) and (i <= voice.ring_modulator.waveforms[rm_index + 1].position))

        local fm1_index = 0
        repeat
            fm1_index = fm1_index + 1
        until fm1_index == #voice.frequency_modulator_1.waveforms
            or ((i >= voice.frequency_modulator_1.waveforms[fm1_index].position) and (i <= voice.frequency_modulator_1.waveforms[fm1_index + 1].position))

        local fm2_index = 0
        repeat
            fm2_index = fm2_index + 1
        until fm2_index == #voice.frequency_modulator_2.waveforms
            or ((i >= voice.frequency_modulator_2.waveforms[fm2_index].position) and (i <= voice.frequency_modulator_2.waveforms[fm2_index + 1].position))

        --

        local ca_1 = voice.carrier.waveforms[index]
        local segment_position = i - voice.carrier.waveforms[index].position
        local segment_length, scale, ca_2, rm_2, fm1_2
        if index < #voice.carrier.waveforms then
            segment_length = voice.carrier.waveforms[index + 1].position - voice.carrier.waveforms[index].position
            scale = voice.carrier.durations[index].scale
            ca_2 = voice.carrier.waveforms[index + 1]
        else
            segment_length = #samples - voice.carrier.waveforms[index].position
            scale = 0
            ca_2 = voice.carrier.waveforms[#voice.carrier.waveforms]
        end

        local rm_1 = voice.ring_modulator.waveforms[rm_index]
        local rm_segment_position = i - voice.ring_modulator.waveforms[rm_index].position
        local rm_segment_length, rm_scale, rm_2
        if rm_index < #voice.ring_modulator.waveforms then
            rm_segment_length = voice.ring_modulator.waveforms[rm_index + 1].position - voice.ring_modulator.waveforms[rm_index].position
            rm_scale = voice.ring_modulator.durations[rm_index].scale
            rm_2 = voice.ring_modulator.waveforms[rm_index + 1]
        else
            rm_segment_length = #samples - voice.ring_modulator.waveforms[rm_index].position
            rm_scale = 0
            rm_2 = voice.ring_modulator.waveforms[#voice.ring_modulator.waveforms]
        end

        local fm1_1 = voice.frequency_modulator_1.waveforms[fm1_index]
        local fm1_segment_position = i - voice.frequency_modulator_1.waveforms[fm1_index].position
        local fm1_segment_length, fm1_scale, fm1_2
        if fm1_index < #voice.frequency_modulator_1.waveforms then
            fm1_segment_length = voice.frequency_modulator_1.waveforms[fm1_index + 1].position - voice.frequency_modulator_1.waveforms[fm1_index].position
            fm1_scale = voice.frequency_modulator_1.durations[fm1_index].scale
            fm1_2 = voice.frequency_modulator_1.waveforms[fm1_index + 1]
        else
            fm1_segment_length = #samples - voice.frequency_modulator_1.waveforms[fm1_index].position
            fm1_scale = 0
            fm1_2 = voice.frequency_modulator_1.waveforms[#voice.frequency_modulator_1.waveforms]
        end

        local fm2_1 = voice.frequency_modulator_2.waveforms[fm2_index]
        local fm2_segment_position = i - voice.frequency_modulator_2.waveforms[fm2_index].position
        local fm2_segment_length, fm2_scale, fm2_2
        if fm2_index < #voice.frequency_modulator_2.waveforms then
            fm2_segment_length = voice.frequency_modulator_2.waveforms[fm2_index + 1].position - voice.frequency_modulator_2.waveforms[fm2_index].position
            fm2_scale = voice.frequency_modulator_2.durations[fm2_index].scale
            fm2_2 = voice.frequency_modulator_2.waveforms[fm2_index + 1]
        else
            fm2_segment_length = #samples - voice.frequency_modulator_2.waveforms[fm2_index].position
            fm2_scale = 0
            fm2_2 = voice.frequency_modulator_2.waveforms[#voice.frequency_modulator_2.waveforms]
        end

        --

        local voice_note = note + voice.transpose

        local morph_position = self:morph_position (segment_position, segment_length, scale)
        local rm_morph_position = self:morph_position (rm_segment_position, rm_segment_length, rm_scale)
        local fm1_morph_position = self:morph_position (fm1_segment_position, fm1_segment_length, fm1_scale)
        local fm2_morph_position = self:morph_position (fm2_segment_position, fm2_segment_length, fm2_scale)

        local ring_modulation = (1 - rm_morph_position) * rm_1.amount/100 + rm_morph_position * rm_2.amount/100

        local sample_without_modulation = self:morph (morph_position, ca_1, ca_2, phase, period)
        samples[i] = (1 - ring_modulation) * sample_without_modulation
                + ring_modulation * sample_without_modulation * self:morph (rm_morph_position, rm_1, rm_2, rm_phase, period)

        local fm1_frequency = self:frequency (fm1_morph_position, fm1_1, fm1_2, voice_note)
        local fm1_deviation = self:morph (fm1_morph_position, fm1_1, fm1_2, fm1_phase, period) * fm1_frequency

        local fm2_frequency = self:frequency (fm2_morph_position, fm2_1, fm2_2, voice_note)
        local fm2_deviation = self:morph (fm2_morph_position, fm2_1, fm2_2, fm2_phase, period) * fm2_frequency

        local frequency_modulation_1 = (1 - fm1_morph_position) * fm1_1.amount + fm1_morph_position * fm1_2.amount
        phase = phase + self:frequency (morph_position, ca_1, ca_2, voice_note) / sample_rate
                      + frequency_modulation_1 * fm1_deviation / sample_rate
        local frequency_modulation_2 = (1 - fm2_morph_position) * fm2_1.amount + fm2_morph_position * fm2_2.amount
        if voice.fm_algorithm == "Parallel" then
            phase = phase + frequency_modulation_2 * fm2_deviation / sample_rate
        end

        rm_phase = rm_phase + self:frequency (fm1_morph_position, rm_1, rm_2, voice_note) / sample_rate
        fm1_phase = fm1_phase + fm1_frequency / sample_rate
        if voice.fm_algorithm == "Serie" then
            fm1_phase = fm1_phase + frequency_modulation_2 * fm2_deviation / sample_rate
        end
        fm2_phase = fm2_phase + fm2_frequency / sample_rate

    end

    -- Create and write the sample buffer

    local index = 1
    while index <= #self.instrument.samples
          and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
        index = index + 1
    end
    local sample_index = #self.instrument.samples + 1
    if index <= #self.instrument.samples then
        sample_index = index
    end
    local sample = self.instrument:insert_sample_at (sample_index)

    local success = sample.sample_buffer:create_sample_data(self.sample_rate, self.bit_depth, 1, #samples)
    ---TODO: ?
    if not success then return end

    local sample_buffer = sample.sample_buffer
    sample_buffer:prepare_sample_data_changes ()
    for i = 1, #samples do
        sample_buffer:set_sample_data (1, i, samples[i])
    end
    sample_buffer:finalize_sample_data_changes ()

    if voice.loop_mode > 1 then
        sample.loop_mode = renoise.Sample.LOOP_MODE_FORWARD
        if voice.loop_mode == 2 then
            sample.loop_release = false
            voice.loop_to = #voice.carrier.waveforms
        else
            sample.loop_release = true
        end
        if voice.loop_from == 1 then
            sample.loop_start = 1
        elseif voice.loop_from >= #voice.carrier.waveforms then
            --~ sample.loop_start = math.floor (voice.waveforms[#voice.waveforms].position / period) * period - period
            sample.loop_start = #samples - period
        else
            sample.loop_start = math.floor (voice.carrier.waveforms[voice.loop_from].position / period) * period
        end
        local loop_to
        if voice.loop_to >= #voice.carrier.waveforms then
            --~ loop_to = math.floor (voice.waveforms[#voice.waveforms].position / period) * period
            loop_to = #samples
        else
            loop_to = math.floor (voice.carrier.waveforms[voice.loop_to].position / period + 1) * period
        end
        if loop_to > #samples then loop_to = #samples end
        sample.loop_end = loop_to
    else
        sample.loop_mode = renoise.Sample.LOOP_MODE_OFF
    end

    -- self.instrument:insert_sample_mapping (renoise.Instrument.LAYER_NOTE_ON, sample_index, note, {range_start, range_end})
    local sample_mapping = self.instrument:sample (sample_index).sample_mapping
    sample_mapping.layer = renoise.Instrument.LAYER_NOTE_ON
    sample_mapping.base_note = note
    sample_mapping.note_range = {range_start, range_end}
    sample.name = "MorphSynth Note " .. name_of_renoise_note (note) .. " Voice " .. voice_index
    sample.volume = voice.volume
    sample.panning = (voice.panning + 50) / 100
    sample.fine_tune = voice.finetune
    if voice.new_note_action == "Continue" then
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_SUSTAIN
    elseif voice.new_note_action == "Note Off" then
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_NOTE_OFF
    else
        sample.new_note_action = renoise.Sample.NEW_NOTE_ACTION_NOTE_CUT
    end
    sample.autofade = voice.autofade

end


----------------------------------------------------------------------------------------------------


function MorphSynth:morph_position (position, length, scale)

    local p = position / length

    -- The "morphing" can be linear, logarithmic or exponential
    if scale > 0 then
        scale = 10 ^ (scale / 25)
        p = math.log ((scale - 1) * p + 1) / math.log (scale)
    elseif scale < 0 then
        scale = 10 ^ (-scale / 25)
        p = (scale ^ p - 1) / (scale - 1)
    end

    return p

end


----------------------------------------------------------------------------------------------------


function MorphSynth:morph (p, w1, w2, phase, period)

    local sample

    local shape = ((1- p) * w1.shape + p * w2.shape) / 100
    local amplitude = 1
    if w1.amplitude and w2.amplitude then
        amplitude = ((1- p) * w1.amplitude + p * w2.amplitude) / 100
    end
    local phase_offset = ((1- p) * w1.phase + p * w2.phase) / 360
    phase = (phase + phase_offset) % 1

    local sample_and_hold = (1 - p) * w1.sample_and_hold + p * w2.sample_and_hold
    if sample_and_hold >= 1 then
        local l = period / sample_and_hold
        if l < 4 then l = 4 end
        phase = math.floor(phase * l) / l
    end

    local func1 = WaveFunctions[w1.operator]
    local inv1 = 1
    if w1.inverted then inv1 = -1 end
    local func2 = WaveFunctions[w2.operator]
    local inv2 = 1
    if w2.inverted then inv2 = -1 end
    sample = amplitude * ((1 - p) * inv1 * func1 (phase, shape) + p * inv2 * func2 (phase, shape))
    --~ sample = amplitude * (((0.5+0.5*math.cos(p*math.pi))^0.5-0.21) * inv1 * func1 (phase, shape) + ((0.5-0.5*math.cos(p*math.pi))^0.5-0.21) * inv2 * func2 (phase, shape))

    return sample

end


----------------------------------------------------------------------------------------------------


function MorphSynth:frequency (p, w1, w2, voice_note)

    local note1 = voice_note + w1.finetune/100
    if w1.transpose then note1 = note1 + w1.transpose end
    local ratio1 = 1
    if w1.ratio_dividend and w1.ratio_divisor then
        ratio1 = w1.ratio_dividend / w1.ratio_divisor
    end
    local offset1 = 0
    if w1.frequency_offset then offset1 = w1.frequency_offset end

    local note2 = voice_note + w2.finetune/100
    if w2.transpose then note2 = note2 + w2.transpose end
    local ratio2 = 1
    if w2.ratio_dividend and w2.ratio_divisor then
        ratio2 = w2.ratio_dividend / w2.ratio_divisor
    end
    local offset2 = 0
    if w2.frequency_offset then offset1 = w2.frequency_offset end

    local morphed_note, ratio, offset
    if note1 ~= note2 then
        morphed_note = (1 - p) * note1 + p * note2
    else
        morphed_note = note1
    end
    if w1 ~= w2 then
        ratio = (1 - p) * ratio1 + p * ratio2
        offset = (1 - p) * offset1 + p * offset2
    else
        ratio = ratio1
        offset = offset1
    end

    return frequency_of_renoise_note (morphed_note) * ratio + offset

end



----------------------------------------------------------------------------------------------------


function MorphSynth:initialize_parameters ()

    self.version = 3

    self.sample_rate = 44100
    self.bit_depth = 16

    self.first_note = 48
    self.last_note = 48
    self.keyzones_step = 3

    self.voices = { {}, {}, {}, {}, {}, {}, {}, {}, }

    local default_duration = { value = 0, unit = "ms", scale = 0 }
    local default_waveform = { operator = "Sine", amplitude = 100, shape = 0, phase = 0, inverted = false, transpose = 0, finetune = 0, sample_and_hold = 0, amount = 0 }

    for i = 1, 8 do

        self.voices[i].volume = 1
        self.voices[i].panning = 0
        self.voices[i].transpose = 0
        self.voices[i].finetune = 0
        self.voices[i].seed = 0
        self.voices[i].new_note_action = "Cut"
        self.voices[i].fm_algorithm = "Parallel"
        self.voices[i].autofade = false
        self.voices[i].envelopes = true

        self.voices[i].loop_mode = 2
        self.voices[i].loop_from = 1
        self.voices[i].loop_to = 1

        self.voices[i].carrier = { durations={}, waveforms={} }
        self.voices[i].ring_modulator = { durations={default_duration}, waveforms={default_waveform} }
        self.voices[i].frequency_modulator_1 = { durations={default_duration}, waveforms={default_waveform} }
        self.voices[i].frequency_modulator_2 = { durations={default_duration}, waveforms={default_waveform} }

    end

    self.voices[1].carrier.durations = { default_duration }
    self.voices[1].carrier.waveforms = { default_waveform }

end


----------------------------------------------------------------------------------------------------


function MorphSynth:save_parameters ()

    local index = 1
    if
        #self.instrument.samples == 1
        and self.instrument:sample(1).name == ""
        and not self.instrument:sample(1).sample_buffer.has_sample_data
    then
        self.instrument.name = "New MorphSynth Instrument"
        --TODO: should check if there is one?
        self.instrument:delete_sample_mapping_at (renoise.Instrument.LAYER_NOTE_ON, 1)
    else
        while index <= #self.instrument.samples
              and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
            index = index + 1
        end
        if index > #self.instrument.samples then
            self.instrument:insert_sample_at (index)
        end
    end

    self.instrument.samples[index].sample_buffer:create_sample_data (44100, 16, 1, 1)

    local name = "MorphSynth Parameters {"

    name = name .. "version=" .. self.version .. ","

    name = name .. "sample_rate=" .. self.sample_rate .. ","
    name = name .. "bit_depth=" .. self.bit_depth .. ","

    name = name .. "first_note=" .. self.first_note .. ","
    name = name .. "last_note=" .. self.last_note .. ","
    name = name .. "keyzones_step=" .. self.keyzones_step .. ","

    name = name .. "voices={"
    for j = 1, 8 do

        local voice = self.voices[j]

        name = name .. "{"

        name = name .. "volume=" .. voice.volume .. ","
        name = name .. "panning=" .. voice.panning .. ","
        name = name .. "transpose=" .. voice.transpose .. ","
        name = name .. "finetune=" .. voice.finetune .. ","
        name = name .. "seed=" .. voice.seed .. ","
        name = name .. 'new_note_action="' .. voice.new_note_action .. '",'
        name = name .. 'fm_algorithm="' .. voice.fm_algorithm .. '",'
        if voice.autofade then
            name = name .. "autofade=true,"
        else
            name = name .. "autofade=false,"
        end
        if voice.envelopes then
            name = name .. "envelopes=true,"
        else
            name = name .. "envelopes=false,"
        end

        name = name .. "loop_mode=" .. voice.loop_mode .. ","
        name = name .. "loop_from=" .. voice.loop_from .. ","
        name = name .. "loop_to=" .. voice.loop_to .. ","

        name = name .. "carrier={"

        name = name .. "durations={"
        for i = 1, #voice.carrier.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.carrier.durations[i].value .. ","
            name = name .. 'unit="' .. voice.carrier.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.carrier.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.carrier.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.carrier.waveforms[i].operator .. '",'
            name = name .. "amplitude=" .. voice.carrier.waveforms[i].amplitude .. ","
            name = name .. "shape=" .. voice.carrier.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.carrier.waveforms[i].phase .. ","
            if voice.carrier.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "transpose=" .. voice.carrier.waveforms[i].transpose .. ","
            name = name .. "finetune=" .. voice.carrier.waveforms[i].finetune .. ","
            name = name .. "sample_and_hold=" .. voice.carrier.waveforms[i].sample_and_hold .. ","
            --~ name = name .. "ring_modulation=" .. voice.carrier.waveforms[i].ring_modulation .. ","
            --~ name = name .. "frequency_modulation_1=" .. voice.carrier.waveforms[i].frequency_modulation_1 .. ","
            --~ name = name .. "frequency_modulation_2=" .. voice.carrier.waveforms[i].frequency_modulation_2 .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- carrier

        name = name .. "ring_modulator={"

        name = name .. "durations={"
        for i = 1, #voice.ring_modulator.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.ring_modulator.durations[i].value .. ","
            name = name .. 'unit="' .. voice.ring_modulator.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.ring_modulator.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.ring_modulator.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.ring_modulator.waveforms[i].operator .. '",'
            name = name .. "shape=" .. voice.ring_modulator.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.ring_modulator.waveforms[i].phase .. ","
            if voice.ring_modulator.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "transpose=" .. voice.ring_modulator.waveforms[i].transpose .. ","
            name = name .. "finetune=" .. voice.ring_modulator.waveforms[i].finetune .. ","
            name = name .. "sample_and_hold=" .. voice.ring_modulator.waveforms[i].sample_and_hold .. ","
            --~ name = name .. "frequency_offset=" .. (voice.ring_modulator.waveforms[i].frequency_offset and voice.ring_modulator.waveforms[i].frequency_offset or 0) .. ","
            name = name .. "amount=" .. voice.ring_modulator.waveforms[i].amount .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- ring_modulator

        name = name .. "frequency_modulator_1={"

        name = name .. "durations={"
        for i = 1, #voice.frequency_modulator_1.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.frequency_modulator_1.durations[i].value .. ","
            name = name .. 'unit="' .. voice.frequency_modulator_1.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.frequency_modulator_1.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.frequency_modulator_1.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.frequency_modulator_1.waveforms[i].operator .. '",'
            name = name .. "shape=" .. voice.frequency_modulator_1.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.frequency_modulator_1.waveforms[i].phase .. ","
            if voice.frequency_modulator_1.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "sample_and_hold=" .. voice.frequency_modulator_1.waveforms[i].sample_and_hold .. ","
            name = name .. "ratio_dividend=" .. (voice.frequency_modulator_1.waveforms[i].ratio_dividend and voice.frequency_modulator_1.waveforms[i].ratio_dividend or 1) .. ","
            name = name .. "ratio_divisor=" .. (voice.frequency_modulator_1.waveforms[i].ratio_divisor and voice.frequency_modulator_1.waveforms[i].ratio_divisor or 1) .. ","
            name = name .. "finetune=" .. voice.frequency_modulator_1.waveforms[i].finetune .. ","
            --~ name = name .. "frequency_offset=" .. (voice.frequency_modulator_1.waveforms[i].frequency_offset and voice.frequency_modulator_1.waveforms[i].frequency_offset or 0) .. ","
            name = name .. "amount=" .. voice.frequency_modulator_1.waveforms[i].amount .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- frequency_modulator_1

        name = name .. "frequency_modulator_2={"

        name = name .. "durations={"
        for i = 1, #voice.frequency_modulator_2.durations do
            name = name .. "{"
            name = name .. "value=" .. voice.frequency_modulator_2.durations[i].value .. ","
            name = name .. 'unit="' .. voice.frequency_modulator_2.durations[i].unit .. '",'
            name = name .. "scale=" .. voice.frequency_modulator_2.durations[i].scale
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "waveforms={"
        for i = 1, #voice.frequency_modulator_2.waveforms do
            name = name .. "{"
            name = name .. 'operator="' .. voice.frequency_modulator_2.waveforms[i].operator .. '",'
            name = name .. "shape=" .. voice.frequency_modulator_2.waveforms[i].shape .. ","
            name = name .. "phase=" .. voice.frequency_modulator_2.waveforms[i].phase .. ","
            if voice.frequency_modulator_2.waveforms[i].inverted then
                name = name .. "inverted=true,"
            else
                name = name .. "inverted=false,"
            end
            name = name .. "sample_and_hold=" .. voice.frequency_modulator_2.waveforms[i].sample_and_hold .. ","
            name = name .. "finetune=" .. voice.frequency_modulator_2.waveforms[i].finetune .. ","
            name = name .. "ratio_dividend=" .. (voice.frequency_modulator_2.waveforms[i].ratio_dividend and voice.frequency_modulator_2.waveforms[i].ratio_dividend or 1) .. ","
            name = name .. "ratio_divisor=" .. (voice.frequency_modulator_2.waveforms[i].ratio_divisor and voice.frequency_modulator_2.waveforms[i].ratio_divisor or 1) .. ","
            --~ name = name .. "frequency_offset=" .. (voice.frequency_modulator_2.waveforms[i].frequency_offset and voice.frequency_modulator_2.waveforms[i].frequency_offset or 0) .. ","
            name = name .. "amount=" .. voice.frequency_modulator_2.waveforms[i].amount .. ","
            name = name .. "},"
        end
        name = name .. "},"

        name = name .. "}," -- frequency_modulator_2

        name = name .. "},"

    end
    name = name .. "},"

    self.instrument.samples[index].name = name .. "}"
    self.instrument.samples[index].volume = 0.0
    self.instrument.samples[index].sample_mapping.note_range = {0, 0}
    self.instrument.samples[index].sample_mapping.velocity_range = {0, 0}

end


----------------------------------------------------------------------------------------------------


function MorphSynth:load_parameters ()

    local index = 1
    while index <= #self.instrument.samples
          and string.sub (self.instrument:sample(index).name, 1, 21) ~= "MorphSynth Parameters" do
        index = index + 1
    end

    if index > #self.instrument.samples then
        self:initialize_parameters ()
        return
    end

    local name = self.instrument.samples[index].name

    local data_string = "return" .. string.sub (name, 22)

    local f = loadstring (data_string)

    local data = f ()

    self.version = data.version

    self.sample_rate = data.sample_rate
    self.bit_depth = data.bit_depth

    self.first_note = data.first_note
    self.last_note = data.last_note
    self.keyzones_step = data.keyzones_step

    self.voices = data.voices

    if self.version < 3 then
        renoise.app():show_custom_prompt ("WARNING", renoise.ViewBuilder():text{text="This instrument was created with a previous, incompatible version\nof MorphSynth. Some parameters cannot be retrieved."}, { "Ok" })
        return true
    end

    return false

end
